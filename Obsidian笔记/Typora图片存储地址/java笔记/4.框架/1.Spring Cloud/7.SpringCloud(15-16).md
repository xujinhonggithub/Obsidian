<h1 align = "center">SpringCloud(H版&Alibaba)技术（15-16初级部分，消息驱动【Stream】与分布式请求链路追踪【Sleuth】）</h1>

# 15. SpringCloud Stream消息驱动

## 15.1 消费驱动概述

### 15.1.1 是什么

![image-20210601105528021](../../../图片/image-20210601105528021.png)



![image-20210601143642839](../../../图片/image-20210601143642839.png)



![image-20210601143551971](../../../图片/image-20210601143551971.png)



官网：https://spring.io/projects/spring-cloud-stream#overview

![image-20210601150326413](../../../图片/image-20210601150326413.png)



![image-20210525104356694](../../../图片/image-20210525104356694.png)



API：https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/

中文指导手册：https://m.wang1314.com/doc/webapp/topic/20971999.html

 


### 15.1.2 设计思想

![image-20210601172435573](../../../图片/image-20210601172435573.png)



标准MQ：

![image-20210602092653159](../../../图片/image-20210602092653159.png)



![image-20210601172538504](../../../图片/image-20210601172538504.png)

![image-20210601172603499](../../../图片/image-20210601172603499.png)



为什么用Cloud Stream？

<img src="../../../图片/image-20210602093246030.png" alt="image-20210602093246030" style="zoom: 67%;" />



![image-20210602093700688](../../../图片/image-20210602093700688.png)



![image-20210602094231169](../../../图片/image-20210602094231169.png)



![image-20210602093914934](../../../图片/image-20210602093914934.png)



![image-20210602094547657](../../../图片/image-20210602094547657.png)

![image-20210602094748332](../../../图片/image-20210602094748332.png)

![image-20210602094841662](../../../图片/image-20210602094841662.png)



![image-20210602095234846](../../../图片/image-20210602095234846.png)

![image-20210602095158175](../../../图片/image-20210602095158175.png)



### 15.1.3 Spring Cloud Stream标准流程套路

![image-20210602095519394](../../../图片/image-20210602095519394.png)

 

![image-20210602095543550](../../../图片/image-20210602095543550.png)

 

![image-20210602100003525](../../../图片/image-20210602100003525.png)

![image-20210602100212981](../../../图片/image-20210602100212981.png)



![image-20210602100151707](../../../图片/image-20210602100151707.png)



### 15.1.4 编码API和常用注解

![image-20210602100256858](../../../图片/image-20210602100256858.png)



## 15.2 案例说明

![image-20210602100708781](../../../图片/image-20210602100708781.png)



## 15.3 消息驱动之生产者

1. 新建模块 cloud-stream-rabbitmq-provider8801

2. pom

   ```
   <dependencies>
       <!--stream rabbit -->
       <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
       </dependency>
       <!--eureka client-->
       <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
       </dependency>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
       <!--监控-->
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-actuator</artifactId>
       </dependency>
       <!--热部署-->
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-devtools</artifactId>
           <scope>runtime</scope>
           <optional>true</optional>
       </dependency>
       <dependency>
           <groupId>org.projectlombok</groupId>
           <artifactId>lombok</artifactId>
           <optional>true</optional>
       </dependency>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-test</artifactId>
           <scope>test</scope>
       </dependency>
   </dependencies>
   ```

   3. yml


```
server:
  port: 8801

spring:
  application:
    name: cloud-stream-provider
  cloud:
    stream:
      binders: #在此处配置要绑定的rabbitmq的服务信息
        defaultRabbit: #表示定义的名称，用于binding整合
          type: rabbit #消息组件类型
          environment: #设置rabbitmq的相关环境配置
            spring:
              rabbitmq:
                host: localhost  #RabbitMQ在本机的用localhost，在服务器的用服务器的ip地址
                port: 5672     # 15672是插件的端口，在SpringBoot的配置文件中，应该使用5672
                username: guest
                password: guest
      bindings: #服务的整合处理
        output: #这个名字是一个通道的名称
          destination: studyExchange #表示要使用的Exchange名称定义
          content-type: application/json #设置消息类型，本次为json，本文要设置为“text/plain”
          binder: defaultRabbit #设置要绑定的消息服务的具体设置（爆红不影响使用，位置没错）

eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔（默认是30S)
    lease-expiration-duration-in-seconds: 5 #如果超过5S间隔就注销节点 默认是90s
    instance-id: send-8801.com #在信息列表时显示主机名称
    prefer-ip-address: true #访问的路径变为IP地址
```

4. 主启动类

   ```
   @SpringBootApplication
   public class StreamMQMain8801 {
   
       public static void main(String[] args) {
           SpringApplication.run(StreamMQMain8801.class, args);
       }
   
   }
   ```

5. 业务类

   ![image-20210525105918836](../../../图片/image-20210525105918836.png)

 新建 service.IMessageProvider 接口

```
public interface IMessageProvider {
    public String send();
}
```

在service下新建 impl.IMessageProviderImpl 实现类

```
import com.angenin.springcloud.service.IMessageProvider;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.messaging.MessageChannel;
import javax.annotation.Resource;
import java.util.UUID;

@EnableBinding(Source.class)    //定义消息的推送管道（Source是spring的）
public class IMessageProviderImpl implements IMessageProvider {

    @Resource
    private MessageChannel output;  //消息发送管道

    @Override
    public String send() {
        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build());     //MessageBuilder是spring的integration.support.MessageBuilder
        System.out.println("*******serial: " + serial);
        return null;
    }
}
```

新建 controller.SendMessageController

```
@RestController
public class SendMessageController {

    @Resource
    private IMessageProvider iMessageProvider;

    @GetMapping("/sendMessage")
    public String sendMessage(){
        return iMessageProvider.send();
    }

}
```

6. 测试

   启动7001，RabbitMQ，启动8801

   然后在RabbitMQ后台可以看到新生成的交换机（在yml`定义的）

`http://localhost:15672/#/exchanges`
<img src="../../../图片/image-20210602150042452.png" alt="image-20210602150042452" style="zoom:67%;" />



然后在浏览器输入：`http://localhost:8801/sendMessage`，多次刷新，后台打印的数据：

![image-20210602150135878](../../../图片/image-20210602150135878.png)



RabbitMQ后台：

<img src="../../../图片/image-20210602150340297.png" alt="image-20210602150340297" style="zoom:67%;" />



## 15.4 消息驱动之消费者

1. 新建模块  cloud-stream-rabbitmq-consumer8802
2. pom

```
<dependencies>
    <!--stream rabbit -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
    </dependency>
    <!--eureka client-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--监控-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!--热部署-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

3. yml

   ```
   server:
     port: 8802
   
   spring:
     application:
       name: cloud-stream-consumer
     cloud:
       stream:
         binders: #在此处配置要绑定的rabbitmq的服务信息
           defaultRabbit: #表示定义的名称，用于binding整合
             type: rabbit #消息组件类型
             environment: #设置rabbitmq的相关环境配置
               spring:
                 rabbitmq:
                   host: localhost  #RabbitMQ在本机的用 localhost，在服务器的用服务器的ip地址
                   port: 5672
                   username: guest
                   password: guest
         bindings: #服务的整合处理
           input: #这个名字是一个通道的名称
             destination: studyExchange #表示要使用的Exchange名称定义
             content-type: application/json #设置消息类型，本次为json，本文要设置为“text/plain”
             binder: defaultRabbit #设置要绑定的消息服务的具体设置（爆红不影响使用，位置没错）
   
   eureka:
     client:
       service-url:
         defaultZone: http://localhost:7001/eureka
     instance:
       lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔（默认是30S)
       lease-expiration-duration-in-seconds: 5 #如果超过5S间隔就注销节点 默认是90s
       instance-id: receive-8802.com #在信息列表时显示主机名称
       prefer-ip-address: true #访问的路径变为IP地址
   ```

4. 主启动类

```
@SpringBootApplication
public class StreamMQMain8802 {

    public static void main(String[] args) {
        SpringApplication.run(StreamMQMain8802.class, args);
    }

}
```

5. 新建  controller.ReceiveMessageListenerController

```
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Controller;


@EnableBinding(Sink.class)
@Controller
public class ReceiveMessageListenerController {

    @Value("${server.port}")
    private String serverPort;

    @StreamListener(Sink.INPUT) //监听
    public void input(Message<String> message){
        System.out.println("消费者1号------>收到的消息：" + message.getPayload() + "\t port：" + serverPort);
    }

}
```

6. 测试

启动 7001，8801，8802

`http://localhost:8801/sendMessage`（8801发送消息）

![image-20210602154024865](../../../图片/image-20210602154024865.png)



8802接收到消息

![image-20210602154101707](../../../图片/image-20210602154101707.png)



## 15.5 分组消费与持久化

<img src="../../../图片/image-20210602162853719.png" alt="image-20210602162853719" style="zoom:67%;" />

按照8802，新建8803。



### 15.5.1 消费



![image-20210602163240270](../../../图片/image-20210602163240270.png)



![image-20210602163305525](../../../图片/image-20210602163305525.png)



8801发送后，8802和8803都能接收到数据（重复消费）；正常情况下应该是有一个消费者消费了8801的消息后，另外的其他消费者就不能消费。这里要把8802和8803看成一个集群，如果8802和8803都接收到了，就都会去做业务，然后本来8801只想让这个集群来做一次消费的，就会变成每个消费者都来消费一次。这是因为8802和8803不是在同一个组（队列）里，不同组可以重复消费，而同一个组里，只有一个消费者能消费，所以需要对消费者进行分组，把所有相同的消费者分到一个组里。（主题会给每个队列发送消息，而每个队列只有一个消费者可以获得消息（同组广播，不同组轮询））

![image-20210602163439294](../../../图片/image-20210602163439294.png)





<img src="../../../图片/image-20210525110912065.png" alt="image-20210525110912065" style="zoom: 67%;" />



![image-20210525110943143](../../../图片/image-20210525110943143.png)



![image-20210525110956777](../../../图片/image-20210525110956777.png)



![image-20210525111010074](../../../图片/image-20210525111010074.png)



![image-20210602210544069](../../../图片/image-20210602210544069.png)



### 15.5.2 分组(队列)

![image-20210602210356825](../../../图片/image-20210602210356825.png)



#### 15.5.2.1 设置不同分组

![image-20210602210712664](../../../图片/image-20210602210712664.png)



修改8802的yml

```
group: angeninA
```

![image-20210525111606721](../../../图片/image-20210525111606721.png)



修改8803的yml

```
group: angeninA
```

![image-20210525111622149](../../../图片/image-20210525111622149.png)



<img src="../../../图片/image-20210602211046063.png" alt="image-20210602211046063" style="zoom:80%;" />



![image-20210602211240630](../../../图片/image-20210602211240630.png)



![image-20210602211256111](../../../图片/image-20210602211256111.png)



![image-20210602211308709](../../../图片/image-20210602211308709.png)



结论：

![image-20210602211353061](../../../图片/image-20210602211353061.png)



#### 15.5.2.2 设置相同分组

![image-20210602211534367](../../../图片/image-20210602211534367.png)

修改8803的yml中group为 angeninA，然后重启8003。

<img src="../../../图片/image-20210525111845070.png" alt="image-20210525111845070" style="zoom:80%;" />

<img src="../../../图片/image-20210525111855479.png" alt="image-20210525111855479" style="zoom:80%;" />



![image-20210602211803805](../../../图片/image-20210602211803805.png)



![image-20210602211815491](../../../图片/image-20210602211815491.png)



![image-20210602211826812](../../../图片/image-20210602211826812.png)



![image-20210602212048322](../../../图片/image-20210602212048322.png)



### 15.5.3 持久化

![image-20210602212307733](../../../图片/image-20210602212307733.png)



1. 停掉8802和8803，去掉8802的`group: angeninA`。

2. 然后8801发送4条消息。

   ![image-20210602212751536](../../../图片/image-20210602212751536.png)



3. 启动8802，8802并没有去拿取消息。（因为8802去掉了`group: angeninA`，所以启动后会再新建一个队列）

![image-20210602212911543](../../../图片/image-20210602212911543.png)



4. 启动8803，启动后获取到8801的消息。（因为8803没删除`group: angeninA`，angeninA队列是在8801发送消息前存在的，所以当8803停机后再启动，就可以获取到停机时8801发送的信息（如果此时同组（队列）里有别的消费者，那么消息会被别的消费者消费掉））

![image-20210602213033186](../../../图片/image-20210602213033186.png)



# 16. SpringCloud Sleuth分布式请求链路追踪

![image-20210602213134399](../../../图片/image-20210602213134399.png)



![image-20210602213349496](../../../图片/image-20210602213349496.png)



https://github.com/spring-cloud/spring-cloud-sleuth

https://cloud.spring.io/spring-cloud-sleuth/reference/html/

<img src="../../../图片/image-20210602213518974.png" alt="image-20210602213518974" style="zoom:67%;" />



## 16.1 搭建链路监控步骤

![image-20210602213605545](../../../图片/image-20210602213605545.png)



![image-20210602213633132](../../../图片/image-20210602213633132.png)



下载jar包：https://repo1.maven.org/maven2/io/zipkin/zipkin-server/

<img src="../../../图片/image-20210602213925384.png" alt="image-20210602213925384" style="zoom: 80%;" />

![image-20210602214011822](../../../图片/image-20210602214011822.png)





下载完后，终端jar包的目录里，然后输入：`java -jar zipkin-server-2.23.2-exec.jar`运行。

<img src="../../../图片/image-20210602214613648.png" alt="image-20210602214613648" style="zoom: 67%;" />

![image-20210602214637149](../../../图片/image-20210602214637149.png)



浏览器输入：`http://localhost:9411/zipkin/`

![image-20210602215003290](../../../图片/image-20210602215003290.png)



### 16.1.1 原理

![image-20210602215017907](../../../图片/image-20210602215017907.png)



![image-20210602215333611](../../../图片/image-20210602215333611.png)



![image-20210602215356815](../../../图片/image-20210602215356815.png)



### 16.1.2 服务提供者 cloud-provider-payment8001

1. 在pom中添加：

```
   <!--包含了sleuth+zipkin-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-zipkin</artifactId>
   </dependency>
```

2. 在yml中添加：

```
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1  #采样率值介于0到1之间，1则表示全部采集（一般不为1，不然高并发性能会有影响）
```

![image-20210525112853467](../../../图片/image-20210525112853467.png)

3. 在PaymentController中添加：

```
   @GetMapping("/payment/zipkin")
   public String paymentZipkin(){
       return "paymentZipkin...";
   }
```

### 16.1.3 服务消费者 cloud-consumer-order80

1. 在pom中添加（和提供者一样）
2. 在yml中添加（和提供者一样）
3. 在 OrderController  中添加：

```
    @GetMapping("/consumer/payment/zipkin")
    public String paymentZipkin(){
        String result = restTemplate.getForObject("http://localhost:8001" + "/payment/zipkin", String.class);
        return result;
    }
```

### 16.1.4 测试

启动7001，8001，80。

浏览器输入：`http://localhost/consumer/payment/zipkin`

![image-20210602220452239](../../../图片/image-20210602220452239.png)



![image-20210602220609975](../../../图片/image-20210602220609975.png)



![image-20210602220658292](../../../图片/image-20210602220658292.png)



![image-20210602220726206](../../../图片/image-20210602220726206.png)